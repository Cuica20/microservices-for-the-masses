= Microservices for the Masses: Script
Matt Raible <https://github.com/mraible>
// Settings:
:idprefix:
:idseparator: -
ifndef::env-github[]
:icons: font
endif::[]
ifdef::env-github,env-browser[]
:toc: preamble
:toclevels: 2
endif::[]
ifdef::env-github[]
:status:
:outfilesuffix: .adoc
:!toc-title:
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
:warning-caption: :warning:
endif::[]
:toc:
:uri-demos: ./../../../demos

// tag::title[]
Welcome everyone!

// My name is Matt Raible and I'm a hick from the sticks. I grew up in the backwoods of Montana with no electricity or running
// water. My sister and I had to walk two miles to school everyday, and yes, it was uphill both ways.

Today, we're going to learn about microservices, their history, how to create them, and communicate between them.

But first, I'd like to share the story of microservices and how they came to be.
// end::title[]

== The History of Microservices
// tag::history[]
According to https://en.wikipedia.org/wiki/Microservices#History[Wikipedia], the term "microservice" was first used a
common architecture style at a workshop of software architects near Venice in May 2011. In May 2012, the same group
decided "microservices" was a more appropriate name.

James Lewis presented some of the ideas behind microservices in March 2012 at 33rd Degree in Kraków. His talk
was called Microservices - Java, the Unix Way. https://github.com/fredgeorge[Fred George] is credited with for sharing
similar ideas at the same time.

https://www.linkedin.com/in/adriancockcroft[Adrian Cockcroft], who was at Netflix at the time, describing this architecture
as "fine grained SOA". He pioneered the style at web scale, as did Joe Walnes, Dan North, Evan Bottcher and Graham Tackley.

Martin Fowler and James Lewis wrote an article titled simply http://martinfowler.com/articles/microservices.html[Microservices]
on March 25, 2014. Years later, this is still considered the definitive article that defines microservices.
// end::history[]

// tag::conways-law[]
Technology have traditionally been organized into technology layers: UI team, database team, operations team.
When teams are separated along these lines, even simple changes can lead to a cross-team project taking time and
budgetary approval.

A smart team will optimise around this and choose the lesser of two evils; forcing the logic into whichever application
they have access to. This is an example of http://www.melconway.com/Home/Committees_Paper.html[Conway's Law] in action.
// end::conways-law[]

[quote, Melvyn Conway, 1967]
Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization's communication structure.

[[img-conways-law]]
.Conway's Law
image::conways-law.png[Conway's Law, 560, scaledwidth=100%, align=center]

// The more interesting story:
// tag::real-history[]
Dr. Peter Rodgers introduced the term "Micro-Web-Services" during a presentation at Cloud Computing Expo in 2005.
Juval Löwy had similar precursor ideas about classes being granular services, as the next evolution of Microsoft architecture in 2007.
"Services are composed using Unix-like pipelines (the Web meets Unix = true loose-coupling). Services can call services
(+multiple language run-times). Complex service-assemblies are abstracted behind simple URI interface. Any service, at any
granularity, can be exposed."
// end::real-history[]

////
He described how a well-designed service platform "applies the underlying architectural principles of the Web and Web
services together with Unix-like scheduling and pipelines to provide radical flexibility and improved simplicity by
providing a platform to apply service-oriented architecture throughout your application environment".
The design, which originated in a research project at Hewlett Packard Labs, aims to make code less brittle and to
make large-scale, complex software systems robust to change. To make "Micro-Web-Services" work, one has to question
and analyze the foundations of architectural styles (such as SOA) and the role of messaging between software components
in order to arrive at a new general computing abstraction. In this case, one can think of resource-oriented computing
(ROC) as a generalized form of the Web abstraction. If in the Unix abstraction "everything is a file", in ROC,
everything is a "Micro-Web-Service". It can contain information, code or the results of computations so that
a service can be either a consumer or producer in a symmetrical and evolving architecture.
////


=== Microservices Philosophy

// tag::ms-philosophy[]
The philosophy of a microservices architecture essentially equals to the Unix philosophy of "Do one thing and do it well".
// end::ms-philosophy[]

=== Characteristics of a Microservices Architecture

// tag::ms-features[]
[build=items]
* Componentization via Services
* Organized around Business Capabilities
* Products not Projects
* Smart endpoints and dumb pipes
* Decentralized Governance
* Decentralized Data Management
* Infrastructure Automation
* Design for failure
* Evolutionary Design
// end:ms-features[]

[duration=5m]
== Why Microservices?
// tag::why[]
It's easier to work on small "do one thing well" services. No single program represents the whole application, so services
can change frameworks (or even languages) without a massive cost. As long as the services use a language agnostic protocol (HTTP or lightweight messaging),
can application can be written in several different platforms - Java, Ruby, Node, Go, .NET, etc. - without issues.

Platform-as-a-Service (PaaS) providers and containers have made it easy to deploy microservices. All the technologies needed to support a monolith
(e.g. load balancing, discovery, process monitoring) are provided by the PaaS, outside of your container. Deployment effort becomes
close to zero.
// end::why[]

== Are Microservices the future?

// tag::future[]
Architecture decisions are usually only evident several years after you make them. Microservices have been successful
at companies like LinkedIn, Twitter, Facebook, Amazon, and Netflix. But that doesn't mean they'll be successful for
your organization. Component boundaries are hard to define. If you're not able to create your components cleanly,
you're just shifting complexity from inside a component to the connections between the components. Also, team
capabilities is something to consider. A poor team will always create a poor system.
// end::future[]

[quote, Martin Fowler]
You shouldn't start with a microservices architecture. Instead begin with a monolith, keep it modular, and split it into microservices once the monolith becomes a problem.

// https://blog.heroku.com/why_microservices_matter

Neal Ford, 4 reasons why microservices resonate
https://www.oreilly.com/ideas/4-reasons-why-microservices-resonate

* Microservices are the first post-DevOps revolution architecture.
* Microservices make change less expensive.
* Microservices are complex.
// Simon Brown, famously notes that “If you can`'t build a monolith, what makes you think microservices are the answer?”
* Microservices enable unique opportunities.
s
